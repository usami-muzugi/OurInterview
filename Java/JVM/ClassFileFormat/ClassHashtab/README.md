# Class 文件校验

在前面章节中提到了许多规则和约束， Java 语言编译器需要遵循这些规则来生成代码，以保证所生成的 Class 文件符合静态和结构化约束。但是 Java 虚拟机无法保证所有它将要加载的Class 文件都来自于正确实现的编译器或者有正确的格式。某些应用程序，譬如网络浏览器可能会下载程序的源码，然后将它们编译为 Class 文件，也有某些应用程序可能会直接下载已被编译过的 Class 文件。这些应用程序需要确定 Class 文件是否是来自于一个错误实现的编译器，甚至是否是来自于想恶意破坏虚拟机的人。
如果仅做编译时检查的话还存在另外一个问题：版本偏差（ Version Skew）。假设有一个用户成功编译了一个名为 PurchaseStockOptions 的类，它是 TradingClass 的子类。但是TradingClass 的内容很可能在上次编译之后又发生了变化，从而导致无法与以前存在的二进制内容向兼容。如原来存在的方法可能被删除、返回值类型可能被修改、字段的类型被改变、字段从实例变量修改为类变量、方法的访问修饰符可能从 public 修改为 private 等等。对于两个类型是否能兼容，在《 Java 语言规范》第 13 章“二进制兼容性” 之中作了详细讨论。
鉴于上述潜在问题， Java 虚拟机需要自己能够独立校验它准备载入的 Class 文件是否能满足规定的约束条件。 Java 虚拟机实现会在文件的链接阶段（ §5.4）对 Class 文件进行必要的校 验。

链接期校验还有助于增强解释器的执行性能，因为解释器在运行期无需再对每个执行指令进行检查。 Java 虚拟机在运行期可以假设所有必要的校验都已经执行过。例如， Java 虚拟机可以确保以下内容：

* 操作数栈不会发生上限或下线溢出。

* 所有局部变量的使用和存储都是有效的。

* 所有 Java 虚拟机指令都拥有正确的参数类型。

  校验器也会对那些不是用 Code 属性（ §4.7.3）中 code[]数组的内容进行校验，这些检验包括如下内容：

  * 确保 final 类不会有子类，以及 final 方法不会被覆盖（ §5.4.5）。
  * 确保除了 Object 之外的每一个类都有直接父类。
  * 确保常量池满足文档静态约束：例如常量池中所有 CONSTANT_Class_info 结构所包含的 name_index 项都是一个指向 CONSTANT_Utf8_info 项的有效常量池索引。
  * 确保常量池之中所有字段引用和方法引用都有有效的名称、类型和方法描述符。

请注意，上述检查不能保证给定的字段或者方法在给定的类中实际存在，也不能保证类型描述符中引用的是一定是一个真实存在的类，而只能保证这些项在形式上是正确的。更多相关的检查会在字节码本身已被验证过之后的解析阶段进行。
Java 虚拟机可以使用两种不同的检查策略：类型检查验证和类型推导验证。对于版本号大于或等于 50.0 的 Class 文件，规定必须使用类型检查验证。由于验证版本号小于 50.0 的 Class 文件的需要，类型推导验证必须被除使用于 Java MECLDC 和 Java Card 平台的虚拟机外的所有虚拟机实现所支持。 使用于 Java ME CLDC 和 Java Card 平台的虚拟机要遵循它们自身的规范。 