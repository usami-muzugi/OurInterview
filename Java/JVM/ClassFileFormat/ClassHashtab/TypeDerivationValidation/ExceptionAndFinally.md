# 异常和 finally 


为了实现 try-finally 结构， 在版本号小于或等于 50.0 的 Java 语言编译器中， 可以①使用将两种特殊指令： jsr（ “跳转到程序子片段”）和 ret（ “程序子片段返回”）组合的方式来生成try-finally 结构的 Java 虚拟机代码。这样的 finally 语句以程序子片段的方式嵌入到 Java虚拟机方法代码中， 有点像异常处理器的代码那样。当使用 jsr 指令来调用程序子片段时， 该指令会把程序子片段结束后应返回的地址值压入操作数栈中， 以便在 jsr 之后的指令能被正确执行。这个地址值会作为 returnAddress 类型数据存放于操作数栈上。 程序子片段的代码中会把返回地址存放在局部变量中， 在程序子片段执行结束时， ret 指令从局部变量中取回返回地址并将执行的控制权交给返回地址处的指令。
程序有多种不同的执行路径会执行到 finally 语句（ 即代表 finally 语句的程序子片段被调用）。如果 try 中全部语句正常地完成的话， 那在执行下一条指令之前，会通过 jsr 指令来调用 finally 的程序子片段。 如果在 try 语句中遇到 break 或 continue 关键字把程序执行权转移到 try 语句之外的话，也会保证在跳转出 try 之前使用 jsr 指令来调用 finally 的程序子片段。 如果 try 语句中遇到了 return，代码的行为如下： 

1. 如果有返回值的话，将返回值保存在局部变量中。
2. 执行 jsr 指令将控制权转到给 finally 语句中。
3. 在 finally 执行完成后，返回事先保存在局部变量中的值。
   编译器会构造特殊的异常处理器， 来保证当 try 语句中有异常发生时，它会拦截住任何类型的异常。如果在 try 语句中有异常抛出，异常处理器的行为是：
   1. 将异常保存在局部变量中。
   2. 执行 jsr 指令将控制权转到给 finally 语句中。
   3. 在执行完 finally 语句后，重新抛出这个事先保存好的异常。


如果想了解更多关于 try-finally 语法结构的实现，请参考 3.13 节 “编译 finally 语句块” 的内容。
finally 语句中的代码也给验证器带来了一些特殊的问题。通常情况下，如果可以通过多条路径抵达一个特殊的指令或是由这些路径找到的某个特殊包含一些不兼容的值的局部变量，那么这个局部变量是不可用的。然而，由于 finally 语句可以在不同的地方被调用，也会导致一些不同的情况：

* 如果从异常处理器处调用，就会带着一个包含异常实例的局部变量。
* 如果从 return 处调用，那么某个局部变量中应该包含着方法返回值。
* 如果从 try 语句的结尾处调用，那么某些局部变量的值可能是不明确的。

验证 finally 语句，不仅要保证 finally 语句本身的代码通过验证，而且在更新完所有 ret指令的后续指令状态后，验证器还得注意到：异常处理器的局部变量中应该有一个异常实例，return 代码期望的局部变量是返回值而不是未确定的值。
验证 finally 语句中的代码是很复杂的，但几个基本的思路如下：

* 每个保持追踪 jsr 目标的指令都需要能到达那个目标指令。对于大部分代码来说，这个列表是空的。对于 finally 语句中的代码来说，列表的长度应该是 1。对于多级嵌入finally 代码来说，列表的长度应该大于 1。


* 对于每条指令及每条 jsr 指令将要转向到那条指令，在 jsr 指令执行后， 就有一个位向量（ Bit Vector）记录着所有对局部变量的访问及修改。


* 执行 ret 指令就意味着从程序子片段中返回，这应该是唯一的一条从程序子片段中返回的路径。两个不同的程序子片段是不同将 ret 指令的执行结果归并到一起。
* 为了对 ret 指令实施数据流分析， 需要进行一些特殊处理。因为验证器知道程序子片段中将从哪些指令中返回，所以它可以找出调用程序子片段的所有的 jsr 指令， 并将它们对应的 ret 指令的操作数栈和局部变量表状态合并。对于合并局部变量表时使用的特殊值定义如下：
  * 如果位向量（前面定义过）表明局部变量在程序子片段中被访问或修改过，那么就使用执行 ret 时局部变量的值的类型。
  * 对于其它局部变量，使用执行 jsr 指令之前的局部变量的类型。 