# 字节码验证器 

本节将介绍更多如何使用类型推导方式来对 Java 虚拟机代码进行校验的细节。
Class 文件中每个方法的代码都要被单独地验证。首先，组成代码的字节序列被会分隔成一系列指令，每条指令在 code[]数组中的起始位置索引将被记录在另外的数组中。 然后， 验证器再次遍历代码并分析每条指令。经过这次遍历之后，会生成一个数组结构用于存储方法中每个 Java虚拟机指令的相关信息。如果有必要的话，验证器会检查每条指令的操作数，以确保它们是合法的。

例如将会检查以下内容：

* 方法分支跳转一定不能超过 code[]数组的范围。

* 所有控制流指令的目标都应该是某条指令的起始处。以 wide 指令为例， wide 操作码可以看作是指令的起始处，但被 wide 指令所修饰的操作码不能再被看作是指令的起始处。

  方法中如果某个分支指向了一条指令中间，那这种行为是非法的。

* 方法会显式声明自己局部变量表的大小，指令所访问或修改的局部变量索引绝不能大于这个限制值。

* 对常量池项的引用必须要求该项符合预期的类型。 譬如， getfield 指令只能引用字段项。

* 代码执行不能终止于指令的中部。

* 代码执行不能超出 code[]数组的尾部。

* 对于所有的异常处理器，由处理器所保护的代码的起点应该是指令的起始处，终点应在代码的尾部。起点必须在终点之前。异常处理器保护的代码必须起始于一个有效的指令，且不能是被 wide 指令修饰的操作码。

对于方法中的每条指令来说，在指令执行之前，验证器会记录下此时操作数栈和局部变量表中的内容。对于操作数栈， 验证器需要知道栈的深度及里面每个值的类型。对于每个局部变量，它需要知道当前局部变量的值的类型，如果当前值还没有被初始化，那么它需要知道这是一个未使用或未知的值。在确定操作数栈上值的类型时，字节码验证器不需要区分到底是哪种整型（例如 byte，short 和 char）。
接下来真正的数据流分析器（ Data-Flow Analyzer）被初始化了。 在方法的第一条指令执行之前，局部变量表中存放方法参数的局部变量就已根据方法描述符中描述的参数数据类型初始化好，此时操作数栈为空，其它的局部变量包含非法（不可使用） 的值。对于那些还没有被检查的指令，分析器不保存与它们有关的操作数栈或局部变量表信息。
接着， 数据流分析器可以开始运作了。它为每条指令都设置一个“变更位”（ Changed Bit），用来表示指令是否需要被检测。最开始时只有方法的第一条指令设置了变更位。数据流分析器执行流程如下面的循环：

1. 选取一个变更位被设置过的指令。如果不能选取到变更位被设置过的指令，那么表示方法被成功地验证过。否则，关闭选取的指令的变更位。


2. 通过下述的方式来模拟操作数栈和局部变量表中指令的行为：

   * 如果指令使用操作数栈中的值，就得确保操作数栈中有足量的数据且栈顶值的类型是合适的。否则验证失败。
   * 如果指令使用局部变量中的值，就得确保那个特定变量的值符合预期的类型。否则验证失败。
   * 如果指令需要往操作数栈存储数据，就得确保操作数栈中有充足的空间来容纳新值，并在模拟的操作数栈的栈顶增加新值的类型。
   * 如果指令试图修改局部变量中的值，记录下当前局部变量包含的新值的类型。

3. 检查当前指令的后续指令。后续指令可以是下述的某一种：

   * 如果当前指令不是非条件的控制转移指令（如 goto， return 或 athrow），那么后续指令就是下一条指令。如果此时超出方法的最后一条指令，那么验证失败。
   * 条件或非条件的分支或转换指令的目标指令。
   * 当前指令的任何异常处理器。

4. 在继续执行下一条指令之前， 需要将当前指令执行结束后操作数栈和局部变量表的状态合并起来。 在处理控制转移到异常处理器的情况时，操作数栈上只包含异常处理器的那个异常类型对象。为此操作数栈上必须有充足的空间来容纳这个值，就如同有指令将值压到栈中一样。

   * 如果这是后续指令是第一次被访问到，在指令执行之前，将采用第 2 和第 3 步中描述的规则，把操作数栈和局部变量表的操作记录为分析器模拟的操作数栈和局部变量表的初始值。为后续指令设置变更位。
   * 如果后续指令之前执行过，只要将操作数栈和局部变量表中按照第 2 和 3 步的规则计算出值合并入模拟的操作数栈和局部变量表中即可。如果之前对这些值有更改过，那么也得设置变更位。

5. 继续第 1 步。
   合并两个操作数栈之前，每个栈上的值的数量必须是相同的。栈上每个元素的类型也必须是相同的，除非两个栈上相应位置有不同类型的 reference 值。在这种情况下，合并后的操作数栈也包含一个 reference 指向两种类型的“最小公共父类” ①。这种最小公共父类应该总是有的，因为 Object 类型是所有类或接口的父类。如果两个操作数栈不能合并，那么验证失败。

   合并两个局部变量表状态之前，局部变量对的数量应该是相同的。如果两个类型不相同，除非它们两个都包含着 reference 值，不然验证器就记录下当前局部变量包含着一个未使用的值。如果两个局部变量对都包含 reference 值，最终合并后的状态是 reference 且指向两种类型的最小公共父类的实例。

   如果数据流分析器在检测某个方法时没有发现错误，那就表示此方法被 Class 文件验证器成功地验证了。

   某些指令和数据类型会使数据流分析器的行为变得更为复杂，接下来我们详细介绍这方面的内容。 





