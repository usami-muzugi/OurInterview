# 实例初始化方法与创建对象 

创建一个新的类实例需要多个步骤的处理过程。 例如下面语句：

```
... ...

new myClass(i, j, k)

... ...
```

它的实现可能像这样：

```
... ...

new #1 // Allocate uninitialized space for myClass

dup // Duplicate object on the operand stack

iload_1 // Push i

iload_2 // Push j

iload_3 // Push k

invokespecial #5 // Invoke myClass.<init>

... ...
```

上述指令序列在操作数栈栈顶上保留着最新创建和初始化过的对象引用 （代码编译成 Java 虚拟机指令集的其它例子请参考第 3 章 “为 Java 虚拟机编译”）。
类 myClass 的实例初始化方法（ §2.9）可以看到新建但未初始化的对象，并且这个对象以this 参数的方式存放在局部变量索引 0 处。在初始化方法通过 this 调用 myClass 或其父类的其它初始化方法之前， 这个初始化方法唯一能做的事情就是在 this 对象上为 myClass 类声明的字段赋值。
在为实例方法做数据流分析时，验证器初始化局部变量索引 0 处为当前类的一个对象。在分析实例初始化方法时，局部变量 0 处包含一个特殊类型用来显示此未初始化对象。在调用这个对象的恰当的实例初始化方法（由当前的类或它的父类）后，由当前的类类型在验证器的操作数栈和局部变量表模型中都放置此特殊类型。验证器会拒绝那些对象初始化之前使用对象及初始化多个对象的代码。除此之外，它还要确保在调用正常的方法之前都得事先调用方法所在类或它的直接父类的实例初始化方法。
与此类似的是，一个特殊类型会被创建并入栈到验证器的操作数栈模型中用来表示 Java 虚拟机 new 指令的结果。这个特殊的类型将被用来区分一个已被完整创建的实例和一个被 new 指令创建，但是还未执行过初始化方法的实例。当一个未初始化类实例的实例初始化方法被调用之后， 所有使用这个特殊类型的地方都被替换成为真实的类实例的类型。这种类型的改变可能影响到数据流分析器对后续指令的分析过程。 

在存储这个特殊类型的时候，指令序号必须一起存储起来。因为操作数栈中有可能会同时出现多于 1 个实例已被创建，但未被初始化的情况，譬如下面这个例子：


```
new InputStream(new Foo(), new InputStream("foo"))
```


如果使用 Java 虚拟机指令集序列来实现这个例子的代码， 那在执行时，操作数栈中就会同时存在 2 个未初始化的 InputStream 实例。 当某个类实例的实例初始化方法被调用， 那在操作数栈或局部变量表中的代表那个被初始化类实例的对象将会被替换掉。
一个有效地指令集序列里，在回向分支（ Backwards Branch）的操作数栈或局部变量表中，以及被 finally语句块或异常处理器所保护的代码的局部变量表中都不允许出现未被初始化的对象。 否则，验证器将可能会被一些有歧义的代码片段所干扰，误以为某些类实例在它需要被初始化的时候已经被初始化过，而实际上， 这个被初始化的实例已经通过前面某个循环被创建了。 