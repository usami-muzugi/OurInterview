# 结构化约束 

在 code[]数组上的结构化约束目的是具体限定 Java 虚拟机指令之间的关系。如下所示：

* 所有指令都必须可以在操作数栈和局部变量表中，基于合适的类型及参数下正常执行，且不用关心调用它的执行路径。指令如果可以操作 int 类型的值，那它同样也有可以去操作 boolean， byte， char 及 short 类型的值。（在§2.3.4 和§2.11.1 节曾经提到，Java 虚拟机内部会将 boolean， byte， char 及 short 转成 int 类型。）


* 如果某条指令可以通过几个不同的执行路径执行，在执行指令之前，不管最终采用哪条执行路径，操作数栈必须有相同的深度（ §2.3.4）。

* 在执行过程中，表示 long 或 double 类型的值的局部变量表值对的存储顺序绝不可以倒置或割裂。对于这样的局部变量值对也绝不可以分开单独使用。

* 在正式地赋值之前，局部变量（或局部变量值对，表示 long 或 double 类型）不可以被访问。

* 在执行过程中，操作数栈不允许增长到超过 max_stack 项的值的深度（ §2.6.2）。

* 在执行过程中，不允许从操作数栈中取出比它包含的全部数据还多的数据。

* 每个 invokespecial 指令应该指明一个实例初始化方法（ §2.9），这个实例初始化方法或是当前类的方法，或是当前类某个父类的方法。

  如果 invokespecial 所指明的实例初始化方法的类不是当前类或父类的方法，并且操作数栈上的目标引用是一个先前使用 new 指令创建的实例，那么 invokespecial 必须从这个实例所属的类中确定一个实例初始化方法。

* 在调用实例初始化方法（ §2.9）时，那个还未被初始化的实例必须存放在操作数栈上适当的位置。如果一个实例已经被初始化过，那就不允许再调用它的实例初始化方法。

* 在调用任意实例的方法或访问任意实例变量之前，那个包含此实例方法或实例变量的实例对象必须是已经被初始化过的。

* 在操作数栈或局部变量表上不允许有未被初始化的类变量作为回向分支（ BackwardsBranch） ①的目标，除非在分支指令上有特殊的未初始化实例类型已经在分支的目标上与自身归并（ §4.10.2.4）。

* 被异常处理器（ §4.10.2.4）所保护的代码中，局部变量表内不允许出现未被初始化的实例。

* 当 jsr 或 jsr_w 指令执行时，在操作数栈或局部变量表中不允许出现未被初始化的实例。

* 除了 Object 类以外，所有实例初始化方法，在访问实例成员之前都要么调用 this()来引用该类中的其它初始化方法，要么通过 super()来调用它的直接父类的实例初始化方法来初始化实例。然而，在调用任何实例初始化方法之前，声明在当前类中的实例字段应当被赋予默认值。

* 所有方法调用的参数都必须与方法描述符（ §4.3.3）相兼容（ JLS §5.3）。

* 方法调用指令的目标实例的类型必须与指令所指定的类或接口的类型相兼容（ JLS§5.2）。除非某个实例初始化方法正在被调用，否则每个 invokespecial 指令的目标类型必须与当前类相兼容。

* 所有返回指令都必须与方法的返回类型匹配。如果方法的返回类型是 boolean， byte，char， short 或 int 就只能使用 ireturn 指令。如果方法返回 float， long 或 doule类型，就分别使用 freturn， lreturn 或 dreturn 指令。如果方法返回 reference类型，就必须使用 areturn指令，并且返回值的类型必须与方法的返回描述符（ §4.3.3）的类型相兼容（ JLS §5.2）。所有的实例初始化方法，类或接口初始化方法和声明返回void 的方法都必须使用 return 指令返回。

* 如果通过 getfield 或 putfield 访问与当前类不在同一运行时包的父类中的protected 字段，那么正在被访问的实例必须与当前类或当前类的子类是相同的。如果通过 invokevirtual 或 invokespecial 访问与当前类不在同一运行时包的父类中的protected 方法，那么正在被访问的实例必须与当前类或当前类的子类是相同的。

* 通过 getfield 访问指令或 putfield 修改指令来操作的实例类型必须与指令所指定的类型相兼容（ JLS §5.2）。

* 通过 putfield 或 putstatic 来保存的值的类型必须与正在操作的实例或类的字段描述符相兼容（ §4.3.2）。如果描述符类型是 boolean， byte， char， short 或 int，那么值就一定是 int 类型。如果描述符类型是 float， long 或 double，那么值就分别是 float， long 或 double。如果描述符是 reference 类型，那么值的类型就必须与描述符类型相兼容（ JLS §5.2）。

* 由 aastore 指令存储到数组中每个值都必须是引用类型。正在被 aastore 指令操作的数组的组件类型（ Component Type， §2.4） 也必须是引用类型。 

* 每个 athrow 指令只能抛出 Throwable 类或它的子类的实例。所有出现在方法异常表中catch_item 项的类都必须是 Throwable 或它的子类。

* 程序执行时，不允许执行超过 code[]数组末端。

* 返回地址（ returnAddress 类型值）不可以从局部变量表中加载。

* 在多个 jsr 或 jsr_w 之后的指令可能会由单个 ret 指令来返回。

* 当某程序子片段（ Subroutine）已经出现在其他程序子片段调用链上时，跳转入该程序子片段的 jsr 或 jsr_w 指令就不能作为另一个程序子片段的返回地址，因为这样会产生无限递归的情况。（当使用 try-finally 结构时， 程序子片段可以在 finally 语句块中嵌套，但这并不会无限递归）。

* 所有 returnAddress 类型的实例至多会返回一次。如果 ret 指令在某码子片段调用链中返回且超过规定实例的 returnAddress 类型的相应地址，之后那个实例就不能再将它作为返回地址。 