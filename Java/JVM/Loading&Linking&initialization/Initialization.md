# 初始化

初始化（ Initialization） 对于类或接口来说，就是执行它的初始化方法（ §2.9）。在发生下列行为时，类或接口将会被初始化：

* 在执行下列需要引用类或接口的 Java 虚拟机指令时： new， getstatic， putstatic或 invokestatic。这些指令通过字段或方法引用来直接或间接地引用其它类。执行上面所述的 new 指令，在类或接口没有被初始化过时就初始化它。执行上面的 getstatic，putstatic 或 invokestatic 指令时，那些解析好的字段或方法中的类或接口如果还没有被初始化那就初始化它。
* 在初次调用 java.lang.invoke.MethodHandle 实例时，它的执行结果为通过 Java虚拟机解析出类型是 2（ REF_getStatic）、 4（ REF_putStatic）或者 6（ REF_invokeStatic）的方法句柄（ §5.4.3.5）。
* 在调用 JDK 核心类库中的反射方法时，例如， Class 类或 java.lang.reflect 包。
* 在对于类的某个子类的初始化时。
* 在它被选定为 Java 虚拟机启动时的初始类（ §5.2） 时。

在类或接口被初始化之前，它必须被链接过，也就是经过验证、准备阶段，且有可能已经被解析完成了。
因为 Java 虚拟机是支持多线程的，所以在初始化类或接口的时候要特别注意线程同步问题，可能其它一些线程也想要初始化相同名称的类或接口。也有可能在初始化一些类或接口时，初始的请求被递归要求初始化它自己。 Java 虚拟机实现需要负责处理好线程同步和递归初始化，具体可以使用下面的步骤来处理。这些处理步骤假定 Class 对象已经被验证和准备过，并且处于下面所述的四种状态之一：

* Class 对象已经被验证和准备过，但还没有被初始化。
* Class 对象正在被其它特定线程初始化。
* Class 对象已经成功被初始化且可以使用。
* Class 对象处于错误的状态，可能因为尝试初始化时失败过

每个类或接口 C，都有一个唯一的初始化锁 LC。如何实现从 C 到 LC 的映射可由 Java 虚拟机实现自行决定。例如， LC 可以是 C 的 Class 对象，或者是与 Class 对象相关的管程（ Monitor）。
初始化 C 的过程如下： 

* 同步 C 的初始化锁 LC。这个操作会导致当前线程一直等待直到可以获得 LC 锁。
* 如果 C 的 Class 对象显示当前 C 的初始化是由其它线程正在进行，那么当前线程释放LC 并进入阻塞状态，直到它知道初始化工作已经由其它线程完成，那么当前线程在此重试此步骤。
* 如果 C 的 Class 对象显示 C 的初始化正由当前线程在做，这就是对初始化的递归请求。释放 LC 并正常返回。
* 如果 C 的 Class 对象显示 Class 已经被初始化完成，那么什么也不做。释放 LC 并正常返回。
* 如果 C 的 Class 对象显示它处于一个错误的状态，就不再初始化了。释放 LC 并抛出NoClassDefFoundError 异常。
* 否则，记录下当前线程正在初始化 C 的 Class 对象，随后释放 LC。根据属性出现在ClassFile 的顺序，利用常量池中的 ConstantValue 属性（ §4.7.2）来初始化 C 中的各个final static 字段。
* 接下来，如果 C 是类而不是接口，而且它的父类 SC 还没有被初始化过，那就对于 SC 也进行完整的初始化过程。当然如果必要的话，需要先验证和准备 SC。如果在初始化 SC 的时候因为抛出异常而中断，那么就获取 LC 后将 C 的 Class 对象标识为错误状态，并通知所有正在等待的线程，最后释放 LC 并异常退出，抛出与 SC 初始化遇到的异常相同的异常。
* 之后，通过查询 C 的定义加载器来决定是否为 C 开启断言机制。
* 执行 C 的类或接口初始化方法。
* 如果正常地执行了类或接口的初始化方法，之后就请求获取 LC，标记 C 的 Class 对象已经被完全初始化，通知所有正在等待的线程，接着释放 LC，正常地退出整个过程。
* 否则，类或接口的初始化方法就必须抛出一个异常 E 并中断退出。如果 E 不是 Error 或它的某个子类，那就创建一个新的 ExceptionInInitializerError 实例，然后将此实例作为E 的参数，之后的步骤就使用 E 这个对象。如果因为 OutOfMemoryError 问题而不能创建ExceptionInInitializerError 实例， 那在之后就使用 OutOfMemoryError 异常对象作为E 的参数。
* 获取 LC，标记下 C 的 Class 对象有错误发生，通知所有的等待线程，释放 LC，将 E 或上述的具体错误对象作为此次意外中断的原因。

虚拟机在具体实现时可以通过省略第 1 步在检查类初始化是否完成时的锁获取过程（在第 4、5 步时释放）而获得更好的性能。允许这样做，是因为在 Java 内存模型中的 happens-before 规则（ JLS §17.4.5）在锁释放后依然存在，因此可以进行相应的优化。 