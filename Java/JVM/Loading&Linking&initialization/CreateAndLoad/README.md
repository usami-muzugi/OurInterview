# 创建和加载

如果要创建标记为 N 的类或接口 C，就需要先在 Java 虚拟机方法区（ §2.5.4）上为 C 创建与虚拟机实现规定相匹配的内部表示。 C 的创建是由另外一个类或接口 D 所触发的，它通过自己的运行时常量池引用了 C。当然， C 的创建也可能是由 D 调用 Java 核心类库（ §2.12）中的某些方法而触发，譬如使用反射等。
如果 C 不是数组类型，那么它就可以通过类加载器加载 C 的二进制表示来创建（参见第 4 章，“ Class 文件格式”）。数组类型没有外部的二进制表示；它们都是由 Java 虚拟机创建，而不是通过类加载器加载的。
Java 虚拟机支持两种类加载器： Java 虚拟机提供的引导类加载器（ Bootstrap ClassLoader）和用户自定义类加载器（ User-Defined Class Loader）。每个用户自定义的类加载器应该是抽象类 ClassLoader 的某个子类的实例。应用程序使用用户自定义类加载器是为了便于扩展 Java 虚拟机的功能，支持动态加载并创建类。当然，它也可以从用户自定义的数据来源来获取类的二进制表示并创建类。例如，用户自定义类加载器可以通过网络下载、动态产生或是从一个加密文件中提取类的信息。
类加载器 L 可能会通过直接创建或是委托其它类加载器的方式来创建 C。如果 L 直接创建 C，我们就可以说 L 定义了（ Define） C，或者， L 是 C 的定义加载器（ Defining Loader）。
当一个类加载器把加载请求委托给其它的类加载器后，发出这个加载请求的加载器与最终完成加载并定义类的类加载器不需要是同一个加载器。如果 L 创建了 C，它可能直接创建了 C 或者是委托了加载请求，我们可以说 L 导致（ Initiate） 了 C 的加载，或者说， L 是 C 的初始加载器（ Initiating Loader）。

在 Java 虚拟机运行时，类或接口不仅仅是由它的名称来确定，而是由一个值对：二进制名称（ §4.2.1）和它的定义类加载器共同确定。每个这样的类或接口都归属于独立的运行时包结构（ Runtime Package）。 类或接口的运行时包结构由包名及类或接口的定义类加载器来决定。

Java 虚拟机通过下面三个过程中之一来创建标记为 N 的类或接口 C：

* 如果 N 表示一个非数组的类或接口，可以用下面的两个方法之一来加载并创建 C：
  * 如果 D 是由引导类加载器所定义，那么引导类加载器初始加载 C（ §5.3.1）。
  * 如果 D 是由用户自定义类加载器所定义，那么此用户自定义类加载器也用来初始加载 C（ §5.3.2）。
* 如果 N 表示一个数组类。数组类是由 Java 虚拟机而不是类加载器创建。然而，在创建数组类 C 的过程中， D 的定义类加载器也要被用到。

如果在类加载过程中有错误产生，某个 LinkageError 的子类的实例将被抛出。抛出位置应当是当前正在（直接或间接）加载类或接口的那段程序中。
如果 Java 虚拟机曾经试图在 D 的验证（ §5.4.1）或解析（ §5.4.3） 阶段、 但又还没有进行初始化（ §5.5）时加载 C 类，当用于加载 C 的初始类加载器抛出 ClassNotFoundException实例时， Java 虚拟机在 D 中必须抛出 NoClassDefFoundError 异常，它的 cause 字段中就保存了那个 ClassNotFoundException 异常实例。
（这里有个需要注意的地方，作为解析（ §5.3.5）过程的一部分，类加载器会递归加载它的父类。如果类加载器在加载父类时因失败而产生 ClassNotFoundException 异常，就应该被包装成 NoClassDefFoundError 异常。）
请注意：一个功能良好的类加载器应当保证下面三个属性：

* 给定相同的名称，类加载器应当总是返回相同的 Class 对象。
* 如果类加载器 L1 将加载类 C 的请求委托给另外的类加载器 L2，那么对于下列的一种类型 T：它可以是 C 的直接父类或直接接口、或是 C 中的字段类型、或是 C 中方法或构造函数的通用参数、或是 C 中方法的返回值， L1 和 L2 都应当返回相同的 Class 对象。
* 如果某个用户自定义的类加载器预先加载了某个类或接口的二进制表示，或是加载一组相关的类型，并在加载时出现异常，那它必须在程序的某个点反映出加载时的错误。 

我们通常使用标识<N， Ld>来表示一个类或接口，这里的 N 表示类或接口的名称， Ld 表示类或接口的定义类加载器。我们也可以使用标识 N Li 来表示一个类或接口，这里的 N 表示类或接口的名称， Li 表示类或接口的初始类加载器。 


