# 从 Class 文件中获取类

下列步骤描述如何使用类加载器 L 从 Class 文件格式的描述中得到标记为 N 的非数组类或接口的 Class 对象。

1. 首先， Java 虚拟机检查 L 是否被记录为标记为 N 的类或接口的初始加载器。如果是，这次创建的尝试动作是无效的，且加载动作抛出 LinkageError 异常。
2. 否则， Java 虚拟机尝试解析二进制表示。但是，这个二进制表示可能不是 C 的有效描述。这个阶段的加载动作必须能够检测出下列错误：
   * 如果发现这个可能的 C 的描述不符合 ClassFile 结构（ §4.1、 §4.8），加载过程将抛出 ClassFormatError 异常。
   * 否则，如果二进制表示的版本号不在虚拟机所支持的最低版本与最高版本之间（ §4.1），加载动作会抛出 UnspportedClassVersionError①异常。
   * 如果描述不能真正表示名称为 N 的类，那么加载过程就会抛出 NoClassDefError 异常或是它的子类异常。
3. 如果 C 有一个直接父类，由 C 到它的直接父类的符号引用就需要使用 5.4.3.1 节描述的算法来解析。需要注意，如果 C 是一个接口，它必须以 Object 作为它的直接父类，并且 Object必须是已经被加载过的。只有 Object 类没有自己的直接父类。
   类或接口解析过程中的异常可以被当作是加载阶段的异常抛出。除此之外，加载阶段还必须可以检查出下列错误：
   * 如果类或接口 C 的直接父类事实上是一个接口，那么加载过程就必须抛IncompatibleClassChangeError 异常。
   * 否则，如果 C 的父类是 C 自己，加载过程就必须抛出 ClassCircularityError 异常。
4. 如果 C 有一些直接父接口，由 C 到它的直接父接口的符号引用就需要使用 5.4.3.1 节描述的算法来解析。在类或接口解析过程中产生的异常可以当作是加载阶段的异常抛出。除此之外，加载过程还必须可以检查到下列错误：
   * 如果类或接口 C 的直接父接口实际上不是一个接口的话，那么加载过程就必须抛出IncompatibleClassChangeError 异常。
   *  否则，如果 C 的某个父接口是 C 自己，加载过程必须抛出 ClassCircularityError异常。


5. Java 虚拟机标记 C 的定义类加载器是 L，并且记录下 L 是 C 的初始加载器（ §5.3.4）。 

