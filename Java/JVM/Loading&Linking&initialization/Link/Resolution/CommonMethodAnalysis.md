# 普通方法解析

为了解析 D 中一个对类或接口 C 中某个方法的未解析符号引用，方法引用中包含的对 C 的符号引用应该首先被解析（ §5.4.3.1）。因此，在解析类的符号引用时出现的任何异常都可以看作解析方法引用的异常而被抛出。如果对 C 的引用成功地被解析，方法引用解析相关的异常就可以被抛出。
当解析一个方法引用时：

1. 首先检查方法引用中的 C 是否类或接口。
   * 如果 C 是接口，那么方法引用就会抛出 IncompatibleClassChangeError 异常。
2. 方法引用解析过程会检查 C 和它的父类中是否包含此方法：
   * 如果 C 中确有一个方法与方法引用的指定名称相同，并且声明是签名多态方法（ Signature Polymorphic Method， §2.9），那么方法的查找过程就被认为是成功的。所有方法描述符中所提到的类也需要解析（ §5.4.3.1）。这次解析的方法是签名多态方法。对于 C 来说，没有必要使用方法引用指定的描述符来声明方法。
   *  否则，如果 C 声明的方法与方法引用拥有同样的名称与描述符，那么方法查找也是成功。
   * 如果 C 有父类的话，那么如第 2 步所述的查找方式递归查找 C 的直接父类。


3. 另外，方法查找过程也会试图从 C 的父接口中去定位所引用的方法。

   * 如果 C 的某个父接口中确实声明了与方法引用相同的名称与描述符的方法，那么方法查找成功。
   * 否则，方法查找失败。

   如果方法查找失败，方法的解析过程就会抛出 NoSuchMethodError 异常。如果方法查找成功且方法是 abstract 的，但 C 类不是 abstract 的，那么此次方法解析就会抛出AbstractMethodError 异常。另外，如果引用的方法对 D 是不可见的（ §5.4.4），方法解析就会抛出 IllegalAccessError 异常。
   如果<E， L1>是所引用方法 m 所在的类或接口， L2 是 D 的定义加载器。假定 m 的返回值类型是 Tr，并且假定 m 的形参类型从 Tf1，„， Tfn。 如果 Tr 不是数组类型，那么 T0 代替 Tr；不然的话， T0 就可以表示 Tr 的元素类型（ §2.4）。由 i 表示 1 到 n 的整数，如果 Tfi 不是数组类型， Ti 就表示 Tfi； 否则， Ti 就是 Tfi 的元素类型（ §2.4）。 Java 虚拟机必须保证对于 i =0„n，加载约束Ti L1 = Ti L 2 能够成立（ §5.3.4）。 

