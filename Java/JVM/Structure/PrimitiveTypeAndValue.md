# 原始类型与值

Java 虚拟机所支持的原始数据类型包括了数值类型（ Numeric Types）、布尔类型 （ Boolean Type §2.3.4） 和 returnAddress 类型（ §2.3.3） 三类。其中数值类型又分为整型类型（ Integral Types， §2.3.1）和浮点类型（ Floating-Point Types， §2.3.2）两种，其中：

整数类型包括：

* byte 类型：值为 8 位有符号二进制补码整数，默认值为零。
* short 类型： 值为 16 位有符号二进制补码整数，默认值为零。
* int 类型： 值为 32 位有符号二进制补码整数，默认值为零。
* long 类型： 值为 64 位有符号二进制补码整数，默认值为零。
* char 类型： 值为使用 16 位无符号整数表示的、指向基本多文本平面（ Basic

Multilingual Plane， BMP①）的 Unicode 值，以 UTF-16 编码，默认值为 Unicode
的 null 值（ '\u0000'）。

浮点类型包括：

* float 类型： 值为单精度浮点数集合②中的元素，或者（如果虚拟机支持的话）是单精度

扩展指数（ Float-Extended-Exponent）集合中的元素。默认值为正数零。

* double 类型：取值范围是双精度浮点数集合中的元素， 或者（ 如果虚拟机支持的话）是双精度扩展指数（ Double-Extended-Exponent）集合中的元素。默认值为正数零。

布尔类型：

* boolean 类型：取值范围为布尔值 true 和 false，默认值为 false。

returnAddress 类型：

* returnAddress 类型：表示一条字节码指令的操作码（ Opcode）。在所有的虚拟机支持的原始类型之中，只有 returnAddress 类型是不能直接 Java 语言的数据类型对应起来的。

## 整型类型与整型值

Java 虚拟机中的整型类型的取值范围如下：

* 对于 byte 类型，取值范围是从-128 至 127（ -27至 27-1），包括-128 和 127。
* 对于 short 类型，取值范围是从−32768 至 32767（ -215至 215-1），包括−32768 和32767。
* 对于 int 类型，取值范围是从−2147483648 至 2147483647（ -231至 231-1），包括−2147483648 和 2147483647。
* 对于 long 类型，取值范围是从−9223372036854775808 至 9223372036854775807（ -263至 263-1），包括−9223372036854775808 和 9223372036854775807。
* 对于 char 类型， 取值范围是从 0 至 65535，包括 0 和 65535。

## 浮点类型、取值集合及浮点值

浮点类型包含 float 类型和 double 类型两种，它们在概念上与《 IEEE Standard for
Binary Floating-Point Arithmetic》 ANSI/IEEE Std. 754-1985（ IEEE, New York）
标准中定义的 32 位单精度和 64 位双精度 IEEE 754 格式取值和操作都是一致的。
IEEE 754 标准的内容不仅包括了正负带符号可数的数值（ Sign-Magnitude Numbers），还包括了正负零、 正负无穷大和一个特殊的“非数字”标识（ Not-a-Number，下文用 NaN 表示）。NaN 值用于表示某些无效的运算操作，例如除数为零等情况。所有 Java 虚拟机的实现都必须支持两种标准的浮点数值集合：单精度浮点数集合和双精度浮点数集合。另外， Java 虚拟机实现可以自由选择是否要支持单精度扩展指数集合和双精度扩展指数集合，也可以选择支持其中的一种或全部。这些扩展指数集合可能在某些特定情况下代替标准浮点数集合来表示 float 和 double 类型的数值。对于一个非零的、可数的任意浮点值，都可以表示为 s×m×2(e-N+1)的形式，其中 s 可以是+1 或者-1， m 是一个小于 2N的正整数， e 是一个介于 Emin=-(2K-1-2)和 Emax=2K-1-1 之间的整数（包括 Emin和 Emax）。这里的 N 和 K 两个参数的取值范围决定于当前采用的浮点数值集合。部分浮点数使用这种规则得到的表示形式可能不是唯一的，例如在指定的数值集合内，可以存在一个数字 v，它能找到特定的 s、 m 和 e 值来表示，使得其中 m 是偶数，并且 e 小于 2K-1，这样我们就能
够通过把 m 的值减半再将 e 的值增加 1 来的方式得到 v 的另外一种不同的表示形式。在这些表示形式中，如果其中某种表示形式中 m 的值满足条件 m≥2N-1的话，那就称这种表示为标准表示（ Normalized Representation），不满足这个条件的其他表示形式就称为非标准表示（ Denormalized Representation）。如果某个数值不存在任何满足 m≥2N-1的表示形式，即不存在任何标准表示，那就称这个数字为非标准值（ Denormalized Value）。在两个必须支持的浮点数值集合和两个可选的浮点数值集合内，对参数 N 和 K（也包括衍生参数 Emin和 Emax）的约束如表 2-1 所示。

表 **2-1 **浮点数值集合的参数

|  参数  | 单精度浮点数集合 | 单精度扩展指数集合 | 双精度浮点数集合 | 双精度扩展指数集合 |
| :--: | :------: | :-------: | :------: | :-------: |
|  N   |    24    |    24     |    53    |    53     |
|  K   |    8     |    ≥11    |    11    |    ≥15    |
| Emin |   +127   |  ≥+1023   |  +1023   |  ≥+16383  |
| Emax |   -126   |  ≤-1022   |  -1022   |  ≤-16382  |

如果虚拟机实现支持了（无论是支持一种还是支持全部）扩展指数集合，那每一种被支持的扩展指数集合都有一个由具体虚拟机实现决定的参数 K，表 2-1 给出了这个参数的约束范围（ ≥11和≥15），这个参数也决定了 Emin和 Emax两个衍生参数的取值范围。上述四种数值集合都不仅包含可数的非零值，还包括五个特殊的数值：正数零、负数零、正无穷大、负无穷大和 NaN。有一点需要注意的是，表 2-1 中的约束是经过精心设计，可以保证每一个单精度浮点数集合中的元素都一定是单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合中的元素。与此类似，每一个双精度浮点数集合中的元素，都一定是双精度扩展指数集合的元素。换句话说，每一种扩展指数集合都有比相应的标准浮点数集合更大的指数取值范围，但是不会有更高的精度。每一个单精度浮点数集合中的元素，都可以精确地使用 IEEE 754 标准中定义的单精度浮点格式表示出来，只有 NaN 一个例外。类似的，每一个双精度浮点数集合中的元素，都可以精确地使用 IEEE 754 标准中定义的双精度浮点格式表示出来， 也只有 NaN 一个例外。不过请读者注意，在这里定义的单精度扩展指数集合和双精度扩展指数集合中的元素和 IEEE 754 标准里面单精度扩展和双精度扩展格式的表示并不完全一致。不过除了 Class 文件格式中必要的浮点数表示描述（ §4.4.4， §4.4.5）以外，本规范并不特别要求表示浮点数值表示形式。上面提到的单精度浮点数集合、单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合都并不是具体的数据类型。虚拟机实现使用一个单精度浮点数集合的元素来表示一个 float 类型的数值在所有场景中都是可行的，但是在某些特定的上下文环境中，也允许虚拟机实现使用单精度扩展指数集合的元素来代替。类似的，虚拟机实现使用一个双精度浮点数集合的元素来表示一个double 类型的数值在所有场景中都是可行的，但是在某些特定的上下文环境中，也允许虚拟机实现使用双精度扩展指数集合的元素来代替。除了 NaN 以外，浮点数集合中的所有元素都是有序的。如果把它们从小到大按顺序排列好，那顺序将会是：负无穷，可数负数、正负零、可数正数、正无穷。浮点数中，正数零和负数零是相等的，但是它们有一些操作会有区别。例如 1.0 除以 0.0 会产生正无穷大的结果，而 1.0 除以-0.0 则会产生负无穷大的结果。NaN 是无序的，对它进行任何的数值比较和等值测试都会返回 false 的比较结果。值得一提的是，有且只有 NaN 一个数与自身比较是否数值上相等时会得到 false 的比较结果，任何数字与NaN 进行非等值比较都会返回 true。

## returnAddress 类型和值

returnAddress 类型会被 Java 虚拟机的 jsr、 ret 和 jsr_w 指令①所使用。returnAddress 类型的值指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原始类型不同， returnAddress 类型在 Java 语言之中并不存在相应的类型，也无法在程序运行期间更改returnAddress 类型的值。

## boolean 类型

虽然 Java 虚拟机定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在Java 虚拟机中没有任何供 boolean 值专用的字节码指令，在 Java 语言之中涉及到 boolean类型值的运算，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替。Java 虚拟机直接支持 boolean 类型的数组，虚拟机的 newarray 指令可以创建这种数组。boolean 的数组类型的访问与修改共用 byte 类型数组的 baload 和 bastore 指令①。































