# 浮点算法

Java 虚拟机采纳了《 IEEE Standard for Binary Floating-Point Arithmetic》（ ANSI/IEEE Std. 754-1985， New York）浮点算法规范中的部分子集。

## Java 虚拟机和 IEEE 754 中的浮点算法

Java 虚拟机中支持的浮点算法和 IEEE 754 标准中的主要差别有：

* 在 Java 虚拟机中的浮点操作在遇到非法操作，如被零除（ Divison By Zero）、上限溢出（ Overflow）、下限溢出（ Underflow）和非精确（ Inexact）时，不会抛出exception、 trap 或者其他 IEEE 754 异常情况中定义的信号。
* 在 Java 虚拟机中不支持 IEEE 754 中的信号浮点比较（ Signaling Floating-PointComparisons）。
* 在 Java 虚拟机中，舍入操作永远使用 IEEE 754 规范中定义的向最接近数舍入模式（ Round To Nearest Mode），无法精确表示的结果将会舍入为最接近的可表示值来保证此值的最低有效位为零（ A Zero Least-Significant Bit），这种模式也是 IEEE754 中的默认模式。不过在 Java 虚拟机里面，将浮点数转化为整型数是使用向零舍入 （ Round Toward Zero），这点属于特别定义，并不意味着 Java 虚拟机要改变浮点运算的舍入模式①。
* 在Java虚拟机中不支持IEEE 754的单精度扩展和双精度扩展格式（ Single Extended Or Double Extended Format）， 但是在双精度浮点数集合和双精度扩展指数集合（ Double And Double Extended-Exponent Value Sets）范围与单精度扩展指数格式的表示方位会有重叠。虚拟机实现可以选择是否支持的单精度扩展指数和双精度扩展指数集合并不等同于 IEEE 754 中的单精度和双精度扩展格式： IEEE 754中的扩展格式规定了扩展精度与扩展指数的范围。

## 浮点模式

每一个方法都有一项属性称为浮点模式（ Floating-Point Mode），取值有两种，要么是FP-strict 模式要么是非 FP-strict 模式。方法的浮点模式决定于 Class 文件中代表该方法的 method_info 结构的访问标志（ access_flags）中的 ACC_STRICT 标志位的取值。如果此标志位为真，则该方法的浮点模式就是 FP-strict，否则就是非 FP-strict 模式。需要注意，编译器编译出来的方法的 ACC_STRICT 标志位对于 JDK 1.1 或者更早的 JDK 版本没有效果。我们说一个操作数栈具有某种浮点模式时，所指的就是包含操作数栈的栈帧所对应的方法具备的浮点模式，类似的，我们说一条 Java 虚拟机字节码指令具备某种浮点模式，所指的也是包含这条指令的方法具备的浮点模式。如果虚拟机实现支持单精度指数扩展集合，那在非 FP-strict 模式的操作数栈上，除非数值集合转换所禁止的，否则一个 float 类型的值将可能会超过单精度浮点数集合的范围。同样的，如果虚拟机实现支持双精度指数扩展集合，那在非FP-strict 模式的操作数栈上，除非数值集合转换所禁止的，否则一个 double 类型的值将可能会超过双精度浮点数集合的范围。在其他的上下文中，无论是操作数栈或者别的地方都不再特别去关注浮点模式， float 和 double 两种浮点值都分别限于单精度和双精度浮点数集合之中。类和实例的字段、数组元素、 局部变量和方法参数的取值范围都限于标准的数值集合之中。

## 数值集合转换

在一些特定场景下，支持扩展指数集合的 Java 虚拟机实现数值在标准浮点数集合与扩展指数集合之间的映射关系是允许和必要的，这种映射操作就称为数值集合转换。数值集合转换并非数据类型转换，而是在同一种数据类型之中不同数值集合的映射操作。在数值集合转换发生的位置，虚拟机实现允许对数值执行下面操作之一：

- 如果一个数值是 float 类型，并且不是单精度浮点数集合中的元素，允许将其映射到单精度浮点数集合中数值最接近的元素。
- 如果一个数值是 double 类型，并且不是双精度浮点数集合中的元素，允许将其映射到双精度浮点数集合中数值最接近的元素。

此外， 在数值集合转换发生的位置， 下面操作是必须的：

* 假设正在执行的 Java 虚拟机字节码指令是非 FP-strict 模式的，但这条指令导致了一个 float 类型的值推入到一个 FP-strict 模式的操作数栈中，例如作为方法参数进行传递或者存储进局部变量、字段或者数组元素之中。如果这个数值不是单精度浮点数集合中的元素， 需要将其映射到单精度浮点数集合中数值最接近的元素。
* 假设正在执行的 Java 虚拟机字节码指令是非 FP-strict 模式的，但这条指令导致了一个 double 类型的值推入到一个 FP-strict 模式的操作数栈中，例如作为方法参数进行传递或者存储进局部变量、字段或者数组元素之中。如果这个数值不是双精度浮点数集合中的元素， 需要将其映射到双精度浮点数集合中数值最接近的元素。

在方法调用中的参数传递（包括 native 方法的调用）、一个非 FP-strict 模式的方法返回浮点型的结果到 FP-strict 模式的调用者栈帧中或者在非 FP-strict 模式的方法中存储浮点型数值到局部变量、字段或者数组元素之中都可能会导致上述的数值集合转换发生。并非所有扩展指数集合中的数值都可以精确映射到标准浮点数值集合的元素之中。如果进行映射的数值过大（扩展指数集合的指数可能比标准数值集合的允许最大值要大），无法在标准数值集
合之中精确表示的话，这个数字将会被转化称对应类型的（正或负）无穷大。如果进行映射的数值过大（扩展指数集合的指数可能比标准数值集合的允许最小值要小），无法在标准数值集合之中精 确表示的话，这个数字将会被转化成最接近的可以表示非正规值（ Denormalized Value）或者相同正负符号零。 
















